<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Main</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Daniel Ferreira and Mansur Mustafin 2023</td></tr><tr><th>Maintainer</th><td>unidsferreira2003@gmail.com and mustafin.mansur02@gmail.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Main</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module holds the primary functions used for the whole program, that is, the functions responsible for
  parsing a string containing the program's input and running a list of instructions built from the parser.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:State">State</a> = <a href="AVLMap.html#t:Map" title="AVLMap">Map</a> String (Either Bool Integer)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Stack">Stack</a> = <a href="Pilha.html#t:Pilha" title="Pilha">Pilha</a> (Either Bool Integer)</li><li class="src short"><a href="#v:createEmptyStack">createEmptyStack</a> :: <a href="Main.html#t:Stack" title="Main">Stack</a></li><li class="src short"><a href="#v:createEmptyState">createEmptyState</a> :: <a href="Main.html#t:State" title="Main">State</a></li><li class="src short"><a href="#v:showEither">showEither</a> :: (Show a, Show b) =&gt; Either a b -&gt; String</li><li class="src short"><a href="#v:stack2Str">stack2Str</a> :: <a href="Main.html#t:Stack" title="Main">Stack</a> -&gt; String</li><li class="src short"><a href="#v:state2Str">state2Str</a> :: <a href="Main.html#t:State" title="Main">State</a> -&gt; String</li><li class="src short"><a href="#v:run">run</a> :: (<a href="Compile.html#t:Code" title="Compile">Code</a>, <a href="Main.html#t:Stack" title="Main">Stack</a>, <a href="Main.html#t:State" title="Main">State</a>) -&gt; (<a href="Compile.html#t:Code" title="Compile">Code</a>, <a href="Main.html#t:Stack" title="Main">Stack</a>, <a href="Main.html#t:State" title="Main">State</a>)</li><li class="src short"><a href="#v:parse">parse</a> :: String -&gt; <a href="Compile.html#t:Program" title="Compile">Program</a></li><li class="src short"><a href="#v:buildData">buildData</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; <a href="Compile.html#t:Program" title="Compile">Program</a></li><li class="src short"><a href="#v:getStatement">getStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getForStatement">getForStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getParenthStatement">getParenthStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getStatement-39-">getStatement'</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; ([<a href="Compile.html#t:Stm" title="Compile">Stm</a>], [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getStoreStatement">getStoreStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getIncrPlusStatement">getIncrPlusStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getIncrMultStatement">getIncrMultStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getIncrMinusStatement">getIncrMinusStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:isBool">isBool</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Bool</li><li class="src short"><a href="#v:getStoreDefaultList">getStoreDefaultList</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:buildDefaultList">buildDefaultList</a> :: String -&gt; Integer -&gt; [<a href="Compile.html#t:Stm" title="Compile">Stm</a>]</li><li class="src short"><a href="#v:getStoreListStatement">getStoreListStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:buildStoreStatements">buildStoreStatements</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; String -&gt; Int -&gt; ([<a href="Compile.html#t:Stm" title="Compile">Stm</a>], [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getIfStatement">getIfStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getWhileStatement">getWhileStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getUpdateVectorStatement">getUpdateVectorStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getAexp">getAexp</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Aexp" title="Compile">Aexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:parseSumSub">parseSumSub</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Aexp" title="Compile">Aexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:parseProd">parseProd</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Aexp" title="Compile">Aexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:parseIntVarPar">parseIntVarPar</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Aexp" title="Compile">Aexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:getBexp">getBexp</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:parseAnd">parseAnd</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:parseBoolEq">parseBoolEq</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:parseNot">parseNot</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:parseIntEqLe">parseIntEqLe</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:parseBoolVarPars">parseBoolVarPars</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>])</li><li class="src short"><a href="#v:testAssembler">testAssembler</a> :: <a href="Compile.html#t:Code" title="Compile">Code</a> -&gt; (String, String)</li><li class="src short"><a href="#v:testParser">testParser</a> :: String -&gt; (String, String)</li><li class="src short"><a href="#v:main">main</a> :: IO ()</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:State" class="def">State</a> = <a href="AVLMap.html#t:Map" title="AVLMap">Map</a> String (Either Bool Integer) <a href="#t:State" class="selflink">#</a></p><div class="doc"><p>Defines the storage of the program, where the values of variables are kept.
    A variable can hold a boolean or integer value</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Stack" class="def">Stack</a> = <a href="Pilha.html#t:Pilha" title="Pilha">Pilha</a> (Either Bool Integer) <a href="#t:Stack" class="selflink">#</a></p><div class="doc"><p>Defines the evaluation stack of the program</p></div></div><div class="top"><p class="src"><a id="v:createEmptyStack" class="def">createEmptyStack</a> :: <a href="Main.html#t:Stack" title="Main">Stack</a> <a href="#v:createEmptyStack" class="selflink">#</a></p><div class="doc"><p>Builds an empty evaluation stack to be used throughout the program</p></div></div><div class="top"><p class="src"><a id="v:createEmptyState" class="def">createEmptyState</a> :: <a href="Main.html#t:State" title="Main">State</a> <a href="#v:createEmptyState" class="selflink">#</a></p><div class="doc"><p>Builds an empty map to be used as the storage throughout the program</p></div></div><div class="top"><p class="src"><a id="v:showEither" class="def">showEither</a> :: (Show a, Show b) =&gt; Either a b -&gt; String <a href="#v:showEither" class="selflink">#</a></p><div class="doc"><p>Prints the left or right value associated with an Either data variable</p></div></div><div class="top"><p class="src"><a id="v:stack2Str" class="def">stack2Str</a> :: <a href="Main.html#t:Stack" title="Main">Stack</a> -&gt; String <a href="#v:stack2Str" class="selflink">#</a></p><div class="doc"><p>Builds a string that represents the contents of the evaluation stack that is given as input.
    The leftmost value of the string represents the value at the top of the evaluation stack,
    while the rightmost value represents the value at the bottom of the stack.</p></div></div><div class="top"><p class="src"><a id="v:state2Str" class="def">state2Str</a> :: <a href="Main.html#t:State" title="Main">State</a> -&gt; String <a href="#v:state2Str" class="selflink">#</a></p><div class="doc"><p>Builds a string that represents the contents of the program's storage.
    Its values are variable-value pairs that are organized in alphabetical order of the variable name.</p></div></div><div class="top"><p class="src"><a id="v:run" class="def">run</a> :: (<a href="Compile.html#t:Code" title="Compile">Code</a>, <a href="Main.html#t:Stack" title="Main">Stack</a>, <a href="Main.html#t:State" title="Main">State</a>) -&gt; (<a href="Compile.html#t:Code" title="Compile">Code</a>, <a href="Main.html#t:Stack" title="Main">Stack</a>, <a href="Main.html#t:State" title="Main">State</a>) <a href="#v:run" class="selflink">#</a></p><div class="doc"><p>Evaluates the instruction at the head of the list of instructions, which must be a valid instruction from the
    <code><a href="Compile.html#t:Inst" title="Compile">Inst</a></code> data type. The instruction updates the evaluation stack and the program's storage accordingly so that
    it can be used by the next instruction. </p></div></div><div class="top"><p class="src"><a id="v:parse" class="def">parse</a> :: String -&gt; <a href="Compile.html#t:Program" title="Compile">Program</a> <a href="#v:parse" class="selflink">#</a></p><div class="doc"><p>Parses a string that represents a program, tokenizing it and translating it into
    the correct statements from the <code><a href="Compile.html#t:Stm" title="Compile">Stm</a></code>, <code><a href="Compile.html#t:Aexp" title="Compile">Aexp</a></code> and <code><a href="Compile.html#t:Bexp" title="Compile">Bexp</a></code> data types</p></div></div><div class="top"><p class="src"><a id="v:buildData" class="def">buildData</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; <a href="Compile.html#t:Program" title="Compile">Program</a> <a href="#v:buildData" class="selflink">#</a></p><div class="doc"><p>Translates a list of token to the correct statements from the <code><a href="Compile.html#t:Stm" title="Compile">Stm</a></code>, <code><a href="Compile.html#t:Aexp" title="Compile">Aexp</a></code> and <code><a href="Compile.html#t:Bexp" title="Compile">Bexp</a></code> data types</p></div></div><div class="top"><p class="src"><a id="v:getStatement" class="def">getStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid statement from the <code><a href="Compile.html#t:Stm" title="Compile">Stm</a></code> data type with the next tokens that appear in the token list given as input</p></div></div><div class="top"><p class="src"><a id="v:getForStatement" class="def">getForStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getForStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:WhileStm" title="Compile">WhileStm</a></code> with the next tokens that appear in the token list given as input</p><p>This function handles the casa where the <code><a href="Compile.html#v:WhileStm" title="Compile">WhileStm</a></code> is built from a <code><a href="Lexer.html#v:ForTok" title="Lexer">ForTok</a></code></p></div></div><div class="top"><p class="src"><a id="v:getParenthStatement" class="def">getParenthStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getParenthStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:ParenthStm" title="Compile">ParenthStm</a></code> with the next tokens that appear in the token list given as input,
    verifying that the next token that is parsed in a <code><a href="Lexer.html#v:OpenTok" title="Lexer">OpenTok</a></code></p></div></div><div class="top"><p class="src"><a id="v:getStatement-39-" class="def">getStatement'</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; ([<a href="Compile.html#t:Stm" title="Compile">Stm</a>], [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getStatement-39-" class="selflink">#</a></p><div class="doc"><p>Builds a list of valid statements with the next tokens that appear in the token list given as input, until
    a <code><a href="Lexer.html#v:CloseTok" title="Lexer">CloseTok</a></code> is found. This fetches all statements that are between a pair of correctly matched parentheses.</p></div></div><div class="top"><p class="src"><a id="v:getStoreStatement" class="def">getStoreStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getStoreStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:StoreStmA" title="Compile">StoreStmA</a></code> or <code><a href="Compile.html#v:StoreStmB" title="Compile">StoreStmB</a></code> with the next tokens that appear in the token list given as input.
    The parser identifies if the statement assigns a boolean or integer value to the chosen variable.</p></div></div><div class="top"><p class="src"><a id="v:getIncrPlusStatement" class="def">getIncrPlusStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getIncrPlusStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:StoreStmA" title="Compile">StoreStmA</a></code> with the next tokens that appear in the token list given as input.
    This effectively stores the sum between the value of the variable of the next token in the list and an 
    arithmetic expression.</p></div></div><div class="top"><p class="src"><a id="v:getIncrMultStatement" class="def">getIncrMultStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getIncrMultStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:StoreStmA" title="Compile">StoreStmA</a></code> with the next tokens that appear in the token list given as input.
    This effectively stores the subtraction between the value of the variable of the next token in the list 
    and an arithmetic expression.</p></div></div><div class="top"><p class="src"><a id="v:getIncrMinusStatement" class="def">getIncrMinusStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getIncrMinusStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:StoreStmA" title="Compile">StoreStmA</a></code> with the next tokens that appear in the token list given as input.
    This effectively stores the product between the value of the variable of the next token in the list and 
    an arithmetic expression.</p></div></div><div class="top"><p class="src"><a id="v:isBool" class="def">isBool</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Bool <a href="#v:isBool" class="selflink">#</a></p><div class="doc"><p>Verifies if a token that represents a boolean constant or a boolean operator is found before the next
    <code><a href="Lexer.html#v:SemiColonTok" title="Lexer">SemiColonTok</a></code> is found in the next tokens that appear in the token list given as input. This function
    is used by <code><a href="Main.html#v:getStoreStatement" title="Main">getStoreStatement</a></code> to verify if a store statement assign a boolean or integer value to a certain variable.</p></div></div><div class="top"><p class="src"><a id="v:getStoreDefaultList" class="def">getStoreDefaultList</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getStoreDefaultList" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:ParenthStm" title="Compile">ParenthStm</a></code> with the next tokens that appear in the token list given as input,
    containing a sequence of statements to store a list full of zeros in a variable.</p></div></div><div class="top"><p class="src"><a id="v:buildDefaultList" class="def">buildDefaultList</a> :: String -&gt; Integer -&gt; [<a href="Compile.html#t:Stm" title="Compile">Stm</a>] <a href="#v:buildDefaultList" class="selflink">#</a></p><div class="doc"><p>Builds the needed statements to store a list with a certain length given as input in a variable whose name
    is also specified in the input.</p></div></div><div class="top"><p class="src"><a id="v:getStoreListStatement" class="def">getStoreListStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getStoreListStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:ParenthStm" title="Compile">ParenthStm</a></code> with the next tokens that appear in the token list given as input,
    containing a sequence of statements to store a list with integer values in a variable.</p></div></div><div class="top"><p class="src"><a id="v:buildStoreStatements" class="def">buildStoreStatements</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; String -&gt; Int -&gt; ([<a href="Compile.html#t:Stm" title="Compile">Stm</a>], [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:buildStoreStatements" class="selflink">#</a></p><div class="doc"><p>Builds the needed statements to store a list with arithmetic expression in a variable whose name
    is given as input.</p></div></div><div class="top"><p class="src"><a id="v:getIfStatement" class="def">getIfStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getIfStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:IfStm" title="Compile">IfStm</a></code> with the next tokens that appear in the token list given as input.</p></div></div><div class="top"><p class="src"><a id="v:getWhileStatement" class="def">getWhileStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getWhileStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:WhileStm" title="Compile">WhileStm</a></code> with the next tokens that appear in the token list given as input.</p><p>This function handles the casa where the <code><a href="Compile.html#v:WhileStm" title="Compile">WhileStm</a></code> is built from a <code><a href="Lexer.html#v:WhileTok" title="Lexer">WhileTok</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:getUpdateVectorStatement" class="def">getUpdateVectorStatement</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Stm" title="Compile">Stm</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getUpdateVectorStatement" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:VarlitAVectorStore" title="Compile">VarlitAVectorStore</a></code> to update the contents of a list with the next
    tokens that appear in the token list given as input</p></div></div><div class="top"><p class="src"><a id="v:getAexp" class="def">getAexp</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Aexp" title="Compile">Aexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getAexp" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#t:Aexp" title="Compile">Aexp</a></code> with the next tokens that appear in the token list given as input.</p><p>This translations takes the precedence of parenthesis and of the arithmetic operators used in the expression into account.</p></div></div><div class="top"><p class="src"><a id="v:parseSumSub" class="def">parseSumSub</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Aexp" title="Compile">Aexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:parseSumSub" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:AddExp" title="Compile">AddExp</a></code> or <code><a href="Compile.html#v:SubExp" title="Compile">SubExp</a></code> with the next tokens that appear in the token list given as input.</p></div></div><div class="top"><p class="src"><a id="v:parseProd" class="def">parseProd</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Aexp" title="Compile">Aexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:parseProd" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:MultExp" title="Compile">MultExp</a></code> with the next tokens that appear in the token list given as input.</p></div></div><div class="top"><p class="src"><a id="v:parseIntVarPar" class="def">parseIntVarPar</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Aexp" title="Compile">Aexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:parseIntVarPar" class="selflink">#</a></p><div class="doc"><p>Builds the correct statement to either fetch a value from a list, or parse a variable or an integer</p><p>This functions also handles the use of parenthesis in arithmetic expressions.</p></div></div><div class="top"><p class="src"><a id="v:getBexp" class="def">getBexp</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:getBexp" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#t:Bexp" title="Compile">Bexp</a></code> with the next tokens that appear in the token list given as input.</p><p>This translations takes the precedence of parenthesis and of the boolean operators used in the expression into account.</p></div></div><div class="top"><p class="src"><a id="v:parseAnd" class="def">parseAnd</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:parseAnd" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:AndExp" title="Compile">AndExp</a></code> with the next tokens that appear in the token list given as input.</p></div></div><div class="top"><p class="src"><a id="v:parseBoolEq" class="def">parseBoolEq</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:parseBoolEq" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:EquExpBool" title="Compile">EquExpBool</a></code> with the next tokens that appear in the token list given as input.</p></div></div><div class="top"><p class="src"><a id="v:parseNot" class="def">parseNot</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:parseNot" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:NegExp" title="Compile">NegExp</a></code> with the next tokens that appear in the token list given as input.</p><p>This function allows the chaining of &quot;not&quot; statements without the use of parenthesis
    such as &quot;not not True&quot; which evaluates to True.</p></div></div><div class="top"><p class="src"><a id="v:parseIntEqLe" class="def">parseIntEqLe</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:parseIntEqLe" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:EquExpInt" title="Compile">EquExpInt</a></code> or <code><a href="Compile.html#v:LeExp" title="Compile">LeExp</a></code> with the next tokens that appear in the token list given as input.</p></div></div><div class="top"><p class="src"><a id="v:parseBoolVarPars" class="def">parseBoolVarPars</a> :: [<a href="Lexer.html#t:Token" title="Lexer">Token</a>] -&gt; Maybe (<a href="Compile.html#t:Bexp" title="Compile">Bexp</a>, [<a href="Lexer.html#t:Token" title="Lexer">Token</a>]) <a href="#v:parseBoolVarPars" class="selflink">#</a></p><div class="doc"><p>Builds a valid <code><a href="Compile.html#v:BoolLit" title="Compile">BoolLit</a></code> or <code><a href="Compile.html#v:VarLitB" title="Compile">VarLitB</a></code> with the next tokens that appear in the token list given as input.</p><p>This functions also handles the use of parenthesis in boolean expressions.</p></div></div><div class="top"><p class="src"><a id="v:testAssembler" class="def">testAssembler</a> :: <a href="Compile.html#t:Code" title="Compile">Code</a> -&gt; (String, String) <a href="#v:testAssembler" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:testParser" class="def">testParser</a> :: String -&gt; (String, String) <a href="#v:testParser" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:main" class="def">main</a> :: IO () <a href="#v:main" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>